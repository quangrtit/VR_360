{% comment %} <!DOCTYPE html>
<html>
	<head>
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			canvas {
				width: 100%;
				height: 100%
			}
			#fullscreenButton {
				position: absolute;
				top: 10px;
				right: 10px;
				z-index: 100;
				padding: 10px;
				background-color: rgba(0, 0, 0, 0.5);
				color: white;
				border: none;
				cursor: pointer;
			}
		</style>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	</head>
	<body>
		<button id="fullscreenButton">Toàn màn hình</button>
		<script>
			let manualControl = false;
			let longitude = 0;
			let latitude = 0;
			let savedX;
			let savedY;
			let savedLongitude;
			let savedLatitude;
			
			// panoramas background
			const panoramasArray = ["/static/images/view4.jpg","/static/images/view4.jpg","/static/images/view4.jpg","/static/images/view4.jpg","/static/images/view4.jpg","/static/images/view4.jpg"];
			let panoramaNumber = Math.floor(Math.random() * panoramasArray.length);

			// setting up the renderer
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			document.body.appendChild(renderer.domElement);
			
			// creating a new scene
			const scene = new THREE.Scene();
			
			// adding a camera
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.target = new THREE.Vector3(0, 0, 0);

			// creation of a big sphere geometry
			const sphere = new THREE.SphereGeometry(100, 100, 40);
			sphere.scale(-1, 1, 1);

			// creation of the sphere material
			const sphereMaterial = new THREE.MeshBasicMaterial();
			const textureLoader = new THREE.TextureLoader();
			sphereMaterial.map = textureLoader.load(panoramasArray[panoramaNumber]);

			// geometry + material = mesh (actual object)
			const sphereMesh = new THREE.Mesh(sphere, sphereMaterial);
			scene.add(sphereMesh);

			// listeners
			document.addEventListener("mousedown", onDocumentMouseDown, false);
			document.addEventListener("mousemove", onDocumentMouseMove, false);
			document.addEventListener("mouseup", onDocumentMouseUp, false);
			document.addEventListener("wheel", onDocumentWheel, false);
				
            let autoRotate = false;   
            function render(){
				requestAnimationFrame(render);
				
				if(!manualControl && !autoRotate){
					longitude += 0.1;
				}

				// limiting latitude from -85 to 85 (cannot point to the sky or under your feet)
                latitude = Math.max(-85, Math.min(85, latitude));

				// moving the camera according to current latitude (vertical movement) and longitude (horizontal movement)
				camera.target.x = 500 * Math.sin(THREE.MathUtils.degToRad(90 - latitude)) * Math.cos(THREE.MathUtils.degToRad(longitude));
				camera.target.y = 500 * Math.cos(THREE.MathUtils.degToRad(90 - latitude));
				camera.target.z = 500 * Math.sin(THREE.MathUtils.degToRad(90 - latitude)) * Math.sin(THREE.MathUtils.degToRad(longitude));
				camera.lookAt(camera.target);

				// calling again render function
				renderer.render(scene, camera);
			}
			
			// when the mouse is pressed, we switch to manual control and save current coordinates
			function onDocumentMouseDown(event){
				event.preventDefault();
				manualControl = true;
				savedX = event.clientX;
				savedY = event.clientY;
				savedLongitude = longitude;
				savedLatitude = latitude;
			}

			// when the mouse moves, if in manual control we adjust coordinates
			function onDocumentMouseMove(event){
				if(manualControl){
					longitude = (savedX - event.clientX) * 0.1 + savedLongitude;
					latitude = (event.clientY - savedY) * 0.1 + savedLatitude;
				}
			}

			// when the mouse is released, we turn manual control off
			function onDocumentMouseUp(event){
				manualControl = false;
			}
			
			// enhanced zoom functionality
			function onDocumentWheel(event){
				event.preventDefault();
				
				// Adjust the zoom speed
				const zoomSpeed = 0.1;
				
				// Calculate new FOV
				let newFOV = camera.fov + event.deltaY * zoomSpeed;
				
				// Set limits for FOV
				newFOV = Math.max(5, Math.min(120, newFOV));
				
				// Update camera FOV and projection matrix
				camera.fov = newFOV;
				camera.updateProjectionMatrix();
				
				// Optional: log current zoom level
				console.log('Current FOV:', camera.fov);
			}
			
			// pressing a key (actually releasing it) changes the texture map
			document.onkeyup = function(event){
				panoramaNumber = (panoramaNumber + 1) % panoramasArray.length;
				sphereMaterial.map = textureLoader.load(panoramasArray[panoramaNumber]);
			}
			
			// handle window resize
			window.addEventListener('resize', onWindowResize, false);

			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			// Fullscreen functionality
			const fullscreenButton = document.getElementById('fullscreenButton');
			fullscreenButton.addEventListener('click', toggleFullscreen);

			function toggleFullscreen() {
				if (!document.fullscreenElement) {
					if (document.documentElement.requestFullscreen) {
						document.documentElement.requestFullscreen();
					} else if (document.documentElement.mozRequestFullScreen) { // Firefox
						document.documentElement.mozRequestFullScreen();
					} else if (document.documentElement.webkitRequestFullscreen) { // Chrome, Safari and Opera
						document.documentElement.webkitRequestFullscreen();
					} else if (document.documentElement.msRequestFullscreen) { // IE/Edge
						document.documentElement.msRequestFullscreen();
					}
					fullscreenButton.textContent = 'Thoát toàn màn hình';
				} else {
					if (document.exitFullscreen) {
						document.exitFullscreen();
					} else if (document.mozCancelFullScreen) { // Firefox
						document.mozCancelFullScreen();
					} else if (document.webkitExitFullscreen) { // Chrome, Safari and Opera
						document.webkitExitFullscreen();
					} else if (document.msExitFullscreen) { // IE/Edge
						document.msExitFullscreen();
					}
					fullscreenButton.textContent = 'Toàn màn hình';
				}
			}

			// Listen for fullscreen change event
			document.addEventListener('fullscreenchange', onFullscreenChange);
			document.addEventListener('webkitfullscreenchange', onFullscreenChange);
			document.addEventListener('mozfullscreenchange', onFullscreenChange);
			document.addEventListener('MSFullscreenChange', onFullscreenChange);

			function onFullscreenChange() {
				if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
					console.log('Entered fullscreen mode');
					onWindowResize(); // Ensure everything is sized correctly
				} else {
					console.log('Exited fullscreen mode');
					onWindowResize(); // Ensure everything is sized correctly
				}
			}
			render();
		</script>
	</body>
</html> {% endcomment %}